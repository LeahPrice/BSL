par(mar = c(5, 4, 1, 2), oma = c(0, 1, 2, 0))
combinePlotsBSL(list(resultCellBSL, resultCellBSLasso, resultCellSemiBSL), which = 1, thetaTrue = true_cell, thin = 1,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
mtext('Approximate Univariate Posteriors', outer = TRUE, cex = 1.5)
# plot using the ggplot2 package
combinePlotsBSL(list(resultCellBSL, resultCellBSLasso, resultCellSemiBSL), which = 2, thetaTrue = true_ma2, thin = 1,
label = c('bsl   ', 'bslasso   ', 'semiBSL'), options.color = list(values=c('red', 'blue', 'green')),
options.linetype = list(values = 2:4), options.size = list(values = rep(1, 3)),
options.theme = list(plot.margin = unit(rep(0.03,4), "npc"), axis.title = element_text(size = 12),
axis.text = element_text(size = 8), legend.text = element_text(size = 12)))
# plot using the ggplot2 package
combinePlotsBSL(list(resultCellBSL, resultCellBSLasso, resultCellSemiBSL), which = 2, thetaTrue = true_cell, thin = 1,
label = c('bsl   ', 'bslasso   ', 'semiBSL'), options.color = list(values=c('red', 'blue', 'green')),
options.linetype = list(values = 2:4), options.size = list(values = rep(1, 3)),
options.theme = list(plot.margin = unit(rep(0.03,4), "npc"), axis.title = element_text(size = 12),
axis.text = element_text(size = 8), legend.text = element_text(size = 12)))
?bsl
library(BSL)
?bsl
?ma2
?cell
library(BSL)
?cell
require(doParallel) # You can use a different package to set up the parallel backend
# Loading the data for this example
data(cell)
true_cell <- c(0.35, 0.001)
# Performing BSL (reduce the number of iterations M if desired)
# Opening up the parallel pools using doParallel
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
resultCellBSL <- bsl(cell$data, n = 500, M = 100, theta0 = cell$start, covRandWalk = cell$cov,
fnSim = cell_sim, fnSum = cell_sum, fnPrior = cell_prior,
simArgs = cell$sim_options, sumArgs = cell$sum_options,
parallel = TRUE, parallelArgs = list(.packages = 'BSL'),
thetaNames = expression(P[m], P[p]), verbose = TRUE)
stopCluster(cl)
registerDoSEQ()
show(resultCellBSL)
summary(resultCellBSL)
plot(resultCellBSL, thetaTrue = true_cell, thin = 20)
?ma2
?cell
?mgnk
require(doParallel) # You can use a different package to set up the parallel backend
# Loading the data for this example
data(mgnk)
# Performing BSL (reduce the number of iterations M if desired)
# Opening up the parallel pools using doParallel
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
resultMgnkBSL <- bsl(mgnk$data, n = 60, M = 800, theta0 = mgnk$start, covRandWalk = mgnk$cov,
fnSim = mgnk_sim, fnSum = mgnk_sum, simArgs = mgnk$sim_options,
parallel = TRUE, parallelArgs = list(.packages = c('BSL', 'MASS', 'elliplot')),
theta_names = expression(a[1],b[1],g[1],k[1],a[2],b[2],g[2],k[2],a[3],b[3],g[3],k[3],
delta[12],delta[13],delta[23]))
stopCluster(cl)
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
resultMgnkBSL <- bsl(mgnk$data, n = 60, M = 800, theta0 = mgnk$start, covRandWalk = mgnk$cov,
fnSim = mgnk_sim, fnSum = mgnk_sum, simArgs = mgnk$sim_options,
parallel = TRUE, parallelArgs = list(.packages = c('BSL', 'MASS', 'elliplot')),
thetaNames = expression(a[1],b[1],g[1],k[1],a[2],b[2],g[2],k[2],a[3],b[3],g[3],k[3],
delta[12],delta[13],delta[23]))
stopCluster(cl)
registerDoSEQ()
library('MASS')
library(BSL)
require(doParallel) # You can use a different package to set up the parallel backend
# Loading the data for this example
data(mgnk)
# Performing BSL (reduce the number of iterations M if desired)
# Opening up the parallel pools using doParallel
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
resultMgnkBSL <- bsl(mgnk$data, n = 60, M = 800, theta0 = mgnk$start, covRandWalk = mgnk$cov,
fnSim = mgnk_sim, fnSum = mgnk_sum, simArgs = mgnk$sim_options,
parallel = TRUE, parallelArgs = list(.packages = c('BSL', 'MASS', 'elliplot')),
thetaNames = expression(a[1],b[1],g[1],k[1],a[2],b[2],g[2],k[2],a[3],b[3],g[3],k[3],
delta[12],delta[13],delta[23]))
stopCluster(cl)
registerDoSEQ()
install.packages('elliplot')
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
resultMgnkBSL <- bsl(mgnk$data, n = 60, M = 800, theta0 = mgnk$start, covRandWalk = mgnk$cov,
fnSim = mgnk_sim, fnSum = mgnk_sum, simArgs = mgnk$sim_options,
parallel = TRUE, parallelArgs = list(.packages = 'BSL', .export = c(MASS::mvrnorm, elliplot::ninenum)),
thetaNames = expression(a[1],b[1],g[1],k[1],a[2],b[2],g[2],k[2],a[3],b[3],g[3],k[3],
delta[12],delta[13],delta[23]))
stopCluster(cl)
registerDoSEQ()
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
resultMgnkBSL <- bsl(mgnk$data, n = 60, M = 800, theta0 = mgnk$start, covRandWalk = mgnk$cov,
fnSim = mgnk_sim, fnSum = mgnk_sum, simArgs = mgnk$sim_options,
parallel = TRUE, parallelArgs = list(.packages = 'BSL', .export = c('MASS::mvrnorm', 'elliplot::ninenum')),
thetaNames = expression(a[1],b[1],g[1],k[1],a[2],b[2],g[2],k[2],a[3],b[3],g[3],k[3],
delta[12],delta[13],delta[23]))
stopCluster(cl)
registerDoSEQ()
MASS::mvrnorm
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
resultMgnkBSL <- bsl(mgnk$data, n = 60, M = 800, theta0 = mgnk$start, covRandWalk = mgnk$cov,
fnSim = mgnk_sim, fnSum = mgnk_sum, simArgs = mgnk$sim_options,
parallel = TRUE, parallelArgs = list(.packages = 'BSL', .export = c('mvrnorm', 'elliplot::ninenum')),
thetaNames = expression(a[1],b[1],g[1],k[1],a[2],b[2],g[2],k[2],a[3],b[3],g[3],k[3],
delta[12],delta[13],delta[23]))
stopCluster(cl)
registerDoSEQ()
mvrnorm
library(MASS)
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
resultMgnkBSL <- bsl(mgnk$data, n = 60, M = 800, theta0 = mgnk$start, covRandWalk = mgnk$cov,
fnSim = mgnk_sim, fnSum = mgnk_sum, simArgs = mgnk$sim_options,
parallel = TRUE, parallelArgs = list(.packages = 'BSL', .export = c('mvrnorm', 'elliplot::ninenum')),
thetaNames = expression(a[1],b[1],g[1],k[1],a[2],b[2],g[2],k[2],a[3],b[3],g[3],k[3],
delta[12],delta[13],delta[23]))
stopCluster(cl)
registerDoSEQ()
require(c('doParallel') # You can use a different package to set up the parallel backend
require(c('doParallel')) # You can use a different package to set up the parallel backend
library(c('MASS', 'elliplot'))
?library
require(doParallel) # You can use a different package to set up the parallel backend
require(MASS)
require(elliplot)
data(mgnk)
# Performing BSL (reduce the number of iterations M if desired)
# Opening up the parallel pools using doParallel
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
resultMgnkBSL <- bsl(mgnk$data, n = 60, M = 800, theta0 = mgnk$start, covRandWalk = mgnk$cov,
fnSim = mgnk_sim, fnSum = mgnk_sum, simArgs = mgnk$sim_options,
parallel = TRUE, parallelArgs = list(.packages = 'BSL', .export = c('mvrnorm', 'ninenum')),
thetaNames = expression(a[1],b[1],g[1],k[1],a[2],b[2],g[2],k[2],a[3],b[3],g[3],k[3],
delta[12],delta[13],delta[23]))
stopCluster(cl)
registerDoSEQ()
resultMgnkBSL <- bsl(mgnk$data, n = 60, M = 800, theta0 = mgnk$start, covRandWalk = mgnk$cov,
fnSim = mgnk_sim, fnSum = mgnk_sum, simArgs = mgnk$sim_options,
parallel = 0, parallelArgs = list(.packages = 'BSL', .export = c('mvrnorm', 'ninenum')),
thetaNames = expression(a[1],b[1],g[1],k[1],a[2],b[2],g[2],k[2],a[3],b[3],g[3],k[3],
delta[12],delta[13],delta[23]))
?cell
devtools::load_all(".")
require(doParallel) # You can use a different package to set up the parallel backend
require(MASS)
require(elliplot)
# Loading the data for this example
data(mgnk)
# Performing BSL (reduce the number of iterations M if desired)
# Opening up the parallel pools using doParallel
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
resultMgnkBSL <- bsl(mgnk$data, n = 60, M = 800, theta0 = mgnk$start, covRandWalk = mgnk$cov,
fnSim = mgnk_sim, fnSum = mgnk_sum, simArgs = mgnk$sim_options,
parallel = TRUE, parallelArgs = list(.packages = 'BSL', .export = c('mvrnorm', 'ninenum')),
thetaNames = expression(a[1],b[1],g[1],k[1],a[2],b[2],g[2],k[2],a[3],b[3],g[3],k[3],
delta[12],delta[13],delta[23]))
stopCluster(cl)
registerDoSEQ()
?foreach
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
resultMgnkBSL <- bsl(mgnk$data, n = 60, M = 800, theta0 = mgnk$start, covRandWalk = mgnk$cov,
fnSim = mgnk_sim, fnSum = mgnk_sum, simArgs = mgnk$sim_options,
parallel = TRUE, parallelArgs = list(.packages = c('BSL', 'MASS'), .export = c('mvrnorm', 'ninenum')),
thetaNames = expression(a[1],b[1],g[1],k[1],a[2],b[2],g[2],k[2],a[3],b[3],g[3],k[3],
delta[12],delta[13],delta[23]))
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
resultMgnkBSL <- bsl(mgnk$data, n = 60, M = 800, theta0 = mgnk$start, covRandWalk = mgnk$cov,
fnSim = mgnk_sim, fnSum = mgnk_sum, simArgs = mgnk$sim_options,
parallel = TRUE, parallelArgs = list(.packages = c('BSL', 'MASS'), .export = c('mvrnorm', 'ninenum')),
thetaNames = expression(a[1],b[1],g[1],k[1],a[2],b[2],g[2],k[2],a[3],b[3],g[3],k[3],
delta[12],delta[13],delta[23]), verbose = TRUE)
stopCluster(cl)
registerDoSEQ()
show(resultMgnkBSL)
summary(resultMgnkBSL)
plot(resultMgnkBSL, thin = 20)
plot(resultMgnkBSL, 2, thin = 20)
plot(resultMgnkBSL, which = 2, thin = 20)
# Performing tuning for BSLasso
lambda_all <- list(exp(seq(-2.5,0.5,length.out=20)), exp(seq(-2.5,0.5,length.out=20)),
exp(seq(-4,-0.5,length.out=20)), exp(seq(-5,-2,length.out=20)))
set.seed(100)
sp_mgnk <- selectPenalty(ssy = mgnk_sum(mgnk$data), n = c(15, 20, 30, 50), lambda_all,
theta = mgnk$start, M = 100, sigma = 1.5, fn_sim = mgnk_sim,
fn_sum = mgnk_sum, sim_options = mgnk$sim_options, standardise = TRUE,
parallel_sim = TRUE, parallel_sim_packages = c('BSL', 'MASS', 'elliplot'),
parallel_main = TRUE)
lambda_all <- list(exp(seq(-2.5,0.5,length.out=20)), exp(seq(-2.5,0.5,length.out=20)),
exp(seq(-4,-0.5,length.out=20)), exp(seq(-5,-2,length.out=20)))
set.seed(100)
sp_mgnk <- selectPenalty(ssy = mgnk_sum(mgnk$data), n = c(15, 20, 30, 50), lambda_all,
theta = mgnk$start, M = 100, sigma = 1.5, fnSim = mgnk_sim,
fnSum = mgnk_sum, simArgs = mgnk$sim_options, standardise = TRUE,
parallelSim = TRUE, parallelSimArgs = list(.packages = c('BSL', 'MASS'), .export = 'ninenum'),
parallelMain = TRUE)
lambda_all <- list(exp(seq(-2.5,0.5,length.out=20)), exp(seq(-2.5,0.5,length.out=20)),
exp(seq(-4,-0.5,length.out=20)), exp(seq(-5,-2,length.out=20)))
set.seed(100)
# Opening up the parallel pools using doParallel
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
sp_mgnk <- selectPenalty(ssy = mgnk_sum(mgnk$data), n = c(15, 20, 30, 50), lambda_all,
theta = mgnk$start, M = 100, sigma = 1.5, fnSim = mgnk_sim,
fnSum = mgnk_sum, simArgs = mgnk$sim_options, standardise = TRUE,
parallelSim = TRUE, parallelSimArgs = list(.packages = c('BSL', 'MASS'), .export = 'ninenum'),
parallelMain = TRUE)
stopCluster(cl)
registerDoSEQ()
sp_mgnk
plot(sp_mgnk)
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
resultMgnkBSLasso <- bsl(mgnk$data, n = 20, M = 80000, theta0 = mgnk$start, covRandWalk = mgnk$cov,
fnSim = mgnk_sim, fnSum = mgnk_sum, simArgs = mgnk$sim_options,
penalty = 0.21, standardise = TRUE, parallel = TRUE,
parallelArgs = list(.packages = c('BSL', 'MASS'), .export = 'ninenum')
thetaNames = expression(a[1],b[1],g[1],k[1],a[2],b[2],g[2],k[2],a[3],b[3],g[3],k[3],
delta[12],delta[13],delta[23]), verbose = TRUE)
stopCluster(cl)
registerDoSEQ()
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
resultMgnkBSLasso <- bsl(mgnk$data, n = 20, M = 80000, theta0 = mgnk$start, covRandWalk = mgnk$cov,
fnSim = mgnk_sim, fnSum = mgnk_sum, simArgs = mgnk$sim_options,
penalty = 0.21, standardise = TRUE, parallel = TRUE,
parallelArgs = list(.packages = c('BSL', 'MASS'), .export = 'ninenum'),
thetaNames = expression(a[1],b[1],g[1],k[1],a[2],b[2],g[2],k[2],a[3],b[3],g[3],k[3],
delta[12],delta[13],delta[23]), verbose = TRUE)
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
resultMgnkBSLasso <- bsl(mgnk$data, n = 20, M = 800, theta0 = mgnk$start, covRandWalk = mgnk$cov,
fnSim = mgnk_sim, fnSum = mgnk_sum, simArgs = mgnk$sim_options,
penalty = 0.21, standardise = TRUE, parallel = TRUE,
parallelArgs = list(.packages = c('BSL', 'MASS'), .export = 'ninenum'),
thetaNames = expression(a[1],b[1],g[1],k[1],a[2],b[2],g[2],k[2],a[3],b[3],g[3],k[3],
delta[12],delta[13],delta[23]), verbose = TRUE)
stopCluster(cl)
registerDoSEQ()
warnings()
summary(resultMgnkBSLasso)
plot(resultMgnkBSLasso, thin = 20)
plot(resultMgnkBSLasso, which = 2, thin = 20)
show(resultMgnkBSLasso)
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
resultMgnkSemiBSL <- bsl(mgnk$data, n = 60, M = 800, theta0 = mgnk$start, covRandWalk = mgnk$cov,
fnSim = mgnk_sim, fnSum = mgnk_sum, simArgs = mgnk$sim_options, method = 'semiBSL',
parallel = TRUE, parallelArgs = list(.packages = c('BSL', 'MASS'), .export = 'ninenum'),
thetaNames = expression(a[1],b[1],g[1],k[1],a[2],b[2],g[2],k[2],a[3],b[3],g[3],k[3],
delta[12],delta[13],delta[23]), verbose = TRUE)
stopCluster(cl)
registerDoSEQ()
show(resultMgnkSemiBSL)
summary(resultMgnkSemiBSL)
plot(resultMgnkSemiBSL, thetaTrue = true_cell, thin = 20)
plot(resultMgnkSemiBSL, which = 2, thin = 20)
# Plotting the results together for comparison
# plot using the R default plot function
par(mar = c(5, 4, 1, 2), oma = c(0, 1, 2, 0))
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thetaTrue = true_cell, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
# Plotting the results together for comparison
# plot using the R default plot function
par(mar = c(5, 4, 1, 2), oma = c(0, 1, 2, 0))
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
mtext('Approximate Univariate Posteriors', outer = TRUE, cex = 1.5)
# Plotting the results together for comparison
# plot using the R default plot function
par(mar = c(2, 2, 0.5, 1), oma = c(0, 1, 2, 0))
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
mtext('Approximate Univariate Posteriors', outer = TRUE, cex = 1.5)
par(mar = c(2, 2, 0.5, 1), oma = c(0, 1, 2, 0))
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
mtext('Approximate Univariate Posteriors', outer = TRUE, cex = 1)
mtext('Approximate Univariate Posteriors', outer = TRUE, cex = 1.2)
par(mar = c(1, 1, 0.5, 1), oma = c(0, 1, 2, 0))
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
mtext('Approximate Univariate Posteriors', outer = TRUE, cex = 1.2)
par(mar = c(5, 1, 0.5, 1), oma = c(0, 1, 2, 0))
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
mtext('Approximate Univariate Posteriors', outer = TRUE, cex = 1.2)
par(mar = c(5, 1, 0.5, 1), oma = c(0, 1, 2, 0))
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
mtext('Approximate Univariate Posteriors', outer = TRUE, cex = 1.2)
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
mtext('Approximate Univariate Posteriors', outer = TRUE, cex = 1.2)
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
# Plotting the results together for comparison
# plot using the R default plot function
par(mar = c(0, 1, 0.5, 1), oma = c(0, 1, 2, 0))
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
mtext('Approximate Univariate Posteriors', outer = TRUE, cex = 1.2)
devtools::load_all(".")
# Plotting the results together for comparison
# plot using the R default plot function
par(mar = c(0, 1, 0.5, 1), oma = c(0, 1, 2, 0))
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
mtext('Approximate Univariate Posteriors', outer = TRUE, cex = 1.2)
# Plotting the results together for comparison
# plot using the R default plot function
par(mar = c(2, 2, 0.5, 1), oma = c(0, 1, 2, 0))
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
mtext('Approximate Univariate Posteriors', outer = TRUE, cex = 1.2)
# Plotting the results together for comparison
# plot using the R default plot function
par(mar = c(4, 3, 1, 2), oma = c(0, 1, 2, 0))
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
mtext('Approximate Univariate Posteriors', outer = TRUE, cex = 1.2)
# Plotting the results together for comparison
# plot using the R default plot function
par(mar = c(4, 3, 1, 2), oma = c(0, 1, 3, 0))
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
mtext('Approximate Univariate Posteriors', outer = TRUE, cex = 1.2)
# Plotting the results together for comparison
# plot using the R default plot function
par(mar = c(4, 3, 1, 2), oma = c(0, 1, 3, 0))
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
?mtext
mtext('Approximate Univariate Posteriors', outer = TRUE, cex = 1.2)
# Plotting the results together for comparison
# plot using the R default plot function
par(mar = c(3, 3, 1, 2), oma = c(0, 1, 3, 0))
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
mtext('Approximate Univariate Posteriors', outer = TRUE, cex = 1.2)
# Plotting the results together for comparison
# plot using the R default plot function
par(mar = c(4, 3, 1, 2), oma = c(0, 1, 3, 0))
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
# Plotting the results together for comparison
# plot using the R default plot function
par(mar = c(4, 3, 1, 1), oma = c(0, 1, 3, 0))
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
mtext('Approximate Univariate Posteriors', outer = TRUE, cex = 1.2)
# Plotting the results together for comparison
# plot using the R default plot function
par(mar = c(4, 4, 1, 1), oma = c(0, 1, 3, 0))
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
mtext('Approximate Univariate Posteriors', outer = TRUE, cex = 1.2)
# Plotting the results together for comparison
# plot using the R default plot function
par(mar = c(4, 4, 1, 1), oma = c(0, 1, 3, 0))
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
mtext('Approximate Univariate Posteriors', outer = 0, cex = 1.2)
# Plotting the results together for comparison
# plot using the R default plot function
par(mar = c(4, 4, 1, 1), oma = c(0, 1, 3, 0))
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
mtext('Approximate Univariate Posteriors', outer = TRUE, at = 5, cex = 1.2)
mtext('Approximate Univariate Posteriors', outer = TRUE, at = 1, cex = 1.2)
mtext('Approximate Univariate Posteriors', outer = TRUE, at = 0, cex = 1.2)
mtext('Approximate Univariate Posteriors', outer = TRUE, at = 0.5, cex = 1.2)
mtext('Approximate Univariate Posteriors', outer = TRUE, line = 0.5, cex = 1.2)
# Plotting the results together for comparison
# plot using the R default plot function
par(mar = c(4, 4, 1, 1), oma = c(0, 1, 3, 0))
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
mtext('Approximate Univariate Posteriors', outer = TRUE, line = 0.5, cex = 1.2)
# Plotting the results together for comparison
# plot using the R default plot function
par(mar = c(4, 4, 1, 1), oma = c(0, 1, 2, 0))
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
mtext('Approximate Univariate Posteriors', outer = TRUE, line = 1, cex = 1.2)
# Plotting the results together for comparison
# plot using the R default plot function
par(mar = c(4, 4, 1, 1), oma = c(0, 1, 2, 0))
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
mtext('Approximate Univariate Posteriors', outer = TRUE, line = 0.75, cex = 1.2)
# plot using the ggplot2 package
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 2, thin = 20,
label = c('bsl   ', 'bslasso   ', 'semiBSL'), options.color = list(values=c('red', 'blue', 'green')),
options.linetype = list(values = 2:4), options.size = list(values = rep(1, 3)),
options.theme = list(plot.margin = unit(rep(0.03,4), "npc"), axis.title = element_text(size = 12),
axis.text = element_text(size = 8), legend.text = element_text(size = 12)))
summary(resultMgnkBSLasso)
plot(sp_mgnk)
set.seed(1)
sp_mgnk <- selectPenalty(ssy = mgnk_sum(mgnk$data), n = c(15, 20, 30, 50), lambda_all,
theta = mgnk$start, M = 100, sigma = 1.5, fnSim = mgnk_sim,
fnSum = mgnk_sum, simArgs = mgnk$sim_options, standardise = TRUE,
parallelSim = TRUE, parallelSimArgs = list(.packages = c('BSL', 'MASS'), .export = 'ninenum'),
parallelMain = TRUE)
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
set.seed(1)
sp_mgnk <- selectPenalty(ssy = mgnk_sum(mgnk$data), n = c(15, 20, 30, 50), lambda_all,
theta = mgnk$start, M = 100, sigma = 1.5, fnSim = mgnk_sim,
fnSum = mgnk_sum, simArgs = mgnk$sim_options, standardise = TRUE,
parallelSim = TRUE, parallelSimArgs = list(.packages = c('BSL', 'MASS'), .export = 'ninenum'),
parallelMain = TRUE)
stopCluster(cl)
registerDoSEQ()
sp_mgnk
plot(sp_mgnk)
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
set.seed(1)
sp_mgnk <- selectPenalty(ssy = mgnk_sum(mgnk$data), n = c(15, 20, 30, 50), lambda_all,
theta = mgnk$start, M = 100, sigma = 1.5, fnSim = mgnk_sim,
fnSum = mgnk_sum, simArgs = mgnk$sim_options, standardise = TRUE,
parallelSim = TRUE, parallelSimArgs = list(.packages = c('BSL', 'MASS'), .export = 'ninenum'),
parallelMain = TRUE)
stopCluster(cl)
registerDoSEQ()
sp_mgnk
plot(sp_mgnk)
# Plotting the results together for comparison
# plot using the R default plot function
par(mar = c(4, 4, 1, 1), oma = c(0, 1, 2, 0))
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 1, thin = 20,
label = c('bsl', 'bslasso', 'semiBSL'), col = c('red', 'blue', 'green'), lty = 2:4, lwd = 1)
mtext('Approximate Univariate Posteriors', outer = TRUE, line = 0.75, cex = 1.2)
# plot using the ggplot2 package
combinePlotsBSL(list(resultMgnkBSL, resultMgnkBSLasso, resultMgnkSemiBSL), which = 2, thin = 20,
label = c('bsl   ', 'bslasso   ', 'semiBSL'), options.color = list(values=c('red', 'blue', 'green')),
options.linetype = list(values = 2:4), options.size = list(values = rep(1, 3)),
options.theme = list(plot.margin = unit(rep(0.03,4), "npc"), axis.title = element_text(size = 12),
axis.text = element_text(size = 8), legend.text = element_text(size = 12)))
devtools::load_all(".")
?mgnk
?mgnk
devtools::load_all(".")
devtools::load_all(".")
?glasso
devtools::load_all(".")
?semiparaKernelEstimate
?plot
?penbsl
?selectPenalty
devtools::load_all(".")
?selectPenalty
?bsl
?par
?density
?mvrnorm
?lines
?abline
?layout
?legend
?foreach
?%dopar%
?'%dopar%'
?validObject
?combinePlotsBSL
?cell
?validObjects
?validObject
?devtools::check
install.packages('roxygen2')
devtools::load_all(".")
summary
devtools::load_all(".")
?plot
devtools::load_all(".")
setwd("D:/Dropbox/BSL High Dim Cov/Code/SemiBSL_R/CRAN package/code/ma2")
y <- readRDS('ma2_data_n50.rds') # load the data
theta0 <- c(0.6, 0.2) # set a starting value of parameter
epsilon <- 2; delta <- 1 # set the desired transformation parameter for summary statistics
# use the simulation function in the package
simulate_ma2 <- BSL::ma2_sim
# summary statistics function, epsilon and delta controls skewness and kurtosis
summStat_ma2 <- function(x, epsilon = 0, delta = 1) {
ssx = sinh((asinh(x) + epsilon) / delta)
return(ssx)
}
# prior function that defines the valid region of parameter theta
prior_ma2 <- function(theta) {
theta[2] < 1 & sum(theta) > -1 & diff(theta) > -1
}
# A list of arguments to put into the bsl function
bslArgs <- list(y, n = 500, M = 100000, theta0 = theta0, fnSim = simulate_ma2,fnSum = summStat_ma2,
fnPrior = prior_ma2, simArgs = list(T=50), sumArgs = list(epsilon=epsilon, delta=delta),
thetaNames = expression(theta[1],theta[2]), plotOnTheFly = TRUE, verbose = TRUE)
# A list of arguments to put into the bsl function
bslArgs <- list(y, n = 500, M = 1000, theta0 = theta0, fnSim = simulate_ma2,fnSum = summStat_ma2,
fnPrior = prior_ma2, simArgs = list(T=50), sumArgs = list(epsilon=epsilon, delta=delta),
thetaNames = expression(theta[1],theta[2]), plotOnTheFly = TRUE, verbose = TRUE)
bslArgs$method <- 'BSL'
bslArgs$covRandWalk <- readRDS('ma2_cov_rw_bsl_e2d1.rds') # load the covariance matrix for MCMC normal random walk
resultMa2BSL <- do.call(bsl, bslArgs)
summary(resultMa2BSL)
plot(resultMa2BSL, which = 2, thin = 10)
